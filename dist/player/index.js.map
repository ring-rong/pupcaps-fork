{"version":3,"file":"index.js","sources":["../../src/common/timecodes.ts","../../src/common/captions.ts","../../src/player/caption-renderer.ts","../../src/player/player.ts","../../src/player/components/player.component.vue","../../src/common/dynamic-css-rules.ts","../../src/player/css-processor.ts","../../src/player/index.ts"],"sourcesContent":["export class Timecode {\n    public readonly hours: number;\n    public readonly minutes: number;\n    public readonly seconds: number;\n    public readonly millis: number;\n\n    constructor(millis: number) {\n        this.millis = millis % 1000;\n\n        this.hours = Math.floor(millis / 3_600_000);\n        const remainingMillisAfterHours = millis % 3_600_000;\n        this.minutes = Math.floor(remainingMillisAfterHours / 60_000);\n        const remainingMillisAfterMinutes = remainingMillisAfterHours % 60_000;\n        this.seconds = Math.floor(remainingMillisAfterMinutes / 1000);\n    }\n\n    public get hh(): string {\n        return String(this.hours).padStart(2, '0');\n    }\n\n    public get mm(): string {\n        return String(this.minutes).padStart(2, '0');\n    }\n\n    public get ss(): string {\n        return String(this.seconds).padStart(2, '0');\n    }\n    public get SSS(): string {\n        return String(this.millis).padStart(3, '0');\n    }\n\n    public get asString(): string {\n        return `${this.hh}:${this.mm}:${this.ss},${this.SSS}`;\n    }\n}\n\nexport function toMillis(timecodes: string | null): number {\n    if (!timecodes) {\n        throw new Error('Timecode is null or undefined');\n    }\n    \n    const parts = timecodes.split(/[:,]/).map(Number);\n\n    if (parts.length !== 4) {\n        throw new Error(`Invalid timecode format: ${timecodes}. Expected format: HH:MM:SS,mmm`);\n    }\n\n    const hours = parts[0];\n    const minutes = parts[1];\n    const seconds = parts[2];\n    const milliseconds = parts[3];\n\n    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds) || isNaN(milliseconds)) {\n        throw new Error(`Invalid timecode values: ${timecodes}. All parts must be numbers.`);\n    }\n\n    return hours * 3_600_000    // hours to millis\n        + minutes * 60_000      // minutes to millis\n        + seconds * 1000        // second to millis\n        + milliseconds;\n}","import {toMillis} from './timecodes';\n\nconst indexLinePattern = /^\\d+$/;\nconst timecodesLinePattern = /^(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})$/;\nconst highlightedWordPattern = /^\\[(.+)](?:\\((\\w+)\\))?$/;\n\nexport interface Word {\n    rawWord: string;\n    isHighlighted: boolean;\n    isBeforeHighlighted: boolean;\n    isAfterHighlighted: boolean;\n    highlightClass?: string;\n}\n\nexport interface Caption {\n    index: number;\n    startTimeMs: number;\n    endTimeMs: number;\n    words: Word[];\n}\n\n/**\n * Groups captions with same words into groups.\n * @param captions captions\n * @returns groups of captions with same words\n */\nexport function captionGroups(captions: Caption[]): Caption[][] {\n    const groups: Caption[][] = [];\n    let lastCaption: Caption | null = null;\n    let lastGroup: Caption[] = [];\n\n    for (const caption of captions) {\n        if (lastCaption && !haveSameWords(caption, lastCaption!)) {\n            groups.push(lastGroup);\n            lastGroup = [];\n        }\n\n        lastGroup.push(caption);\n        lastCaption = caption;\n    }\n\n    if (lastGroup.length) {\n        groups.push(lastGroup);\n    }\n\n    return groups;\n}\n\nexport function haveSameWords(caption1: Caption, caption2: Caption): boolean {\n    if (caption1.words.length != caption2.words.length) {\n        return false;\n    }\n\n    for (let i =0; i < caption1.words.length; i++) {\n        if (caption1.words[i].rawWord != caption2.words[i].rawWord) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function readCaptions(srtContent: string): Caption[] {\n    const lines = srtContent.split('\\n').map(line => line.trim());\n    const captions: Caption[] = [];\n\n    let index: number = 0;\n    let timecodesStart: string | null = null;\n    let timecodesEnd: string | null = null;\n    let captionText: string[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        let match;\n        \n        // Skip empty lines\n        if (line.length === 0) {\n            // If we have accumulated caption text, process it\n            if (captionText.length > 0 && timecodesStart && timecodesEnd) {\n                try {\n                    const start = toMillis(timecodesStart);\n                    const end = toMillis(timecodesEnd);\n                    const fullText = captionText.join(' ');\n                    const words = readWords(fullText);\n\n                    captions.push({\n                        index,\n                        words,\n                        startTimeMs: start,\n                        endTimeMs: end,\n                    });\n                } catch (error) {\n                    console.error(`Error parsing timecodes for caption ${index}: ${error instanceof Error ? error.message : String(error)}`);\n                    console.warn(`Skipping caption. Start: \"${timecodesStart}\", End: \"${timecodesEnd}\", Text: \"${captionText.join(' ')}\"`);\n                }\n                \n                // Reset for next caption\n                captionText = [];\n                timecodesStart = null;\n                timecodesEnd = null;\n            }\n            continue;\n        }\n        \n        if ((match = line.match(indexLinePattern))) {\n            // New caption index\n            index = Number(line);\n        } else if ((match = line.match(timecodesLinePattern))) {\n            // Timecodes line\n            timecodesStart = match[1];\n            timecodesEnd = match[2];\n        } else {\n            // This should be caption text\n            if (!timecodesStart || !timecodesEnd) {\n                console.warn(`Skipping caption at index ${index}: Missing timecodes. Line: \"${line}\"`);\n                continue;\n            }\n            captionText.push(line);\n        }\n    }\n    \n    // Handle last caption if file doesn't end with empty line\n    if (captionText.length > 0 && timecodesStart && timecodesEnd) {\n        try {\n            const start = toMillis(timecodesStart);\n            const end = toMillis(timecodesEnd);\n            const fullText = captionText.join(' ');\n            const words = readWords(fullText);\n\n            captions.push({\n                index,\n                words,\n                startTimeMs: start,\n                endTimeMs: end,\n            });\n        } catch (error) {\n            console.error(`Error parsing timecodes for caption ${index}: ${error instanceof Error ? error.message : String(error)}`);\n            console.warn(`Skipping caption. Start: \"${timecodesStart}\", End: \"${timecodesEnd}\", Text: \"${captionText.join(' ')}\"`);\n        }\n    }\n\n    return captions;\n}\n\nexport function readWords(text: string): Word[] {\n    const words = splitText(text);\n    const highlightedIndex = words.findIndex(word => word.match(highlightedWordPattern));\n\n    const res: Word[] = [];\n\n    for (let i = 0; i < words.length; i++) {\n        const word = words[i];\n        const match = word.match(highlightedWordPattern);\n        const rawWord = match ? match[1] : word;\n        const highlightClass = match && match[2] ? match[2] : null;\n\n        const isHighlighted = Boolean(match);\n        const isBeforeHighlighted = Boolean(~highlightedIndex && !isHighlighted && i < highlightedIndex);\n        const isAfterHighlighted = Boolean(~highlightedIndex && !isHighlighted && i > highlightedIndex);\n\n        const wordObject: Word = {\n            rawWord,\n            isHighlighted,\n            isBeforeHighlighted,\n            isAfterHighlighted,\n        };\n\n        if (highlightClass) {\n            wordObject.highlightClass = highlightClass;\n        }\n\n        res.push(wordObject);\n    }\n\n    return res;\n}\n\nexport function splitText(text: string): string[] {\n    const words: string[] = [];\n\n    let currentWord = '';\n    let isCurrentHighlighted = false;\n\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        const isWhitespace = /^\\s$/.test(char);\n        const isPunctuation = /[,.!?]/.test(char);\n\n        if (!isWhitespace) {\n            if (!isPunctuation) {\n                currentWord += char;\n                switch (char) {\n                    case '[':\n                    case '(':\n                        isCurrentHighlighted = true;\n                        break;\n                    case ']':\n                    case ')':\n                        isCurrentHighlighted = false;\n                        break;\n                }\n            } else {\n                if (currentWord) {\n                    currentWord += char;\n                } else {\n                    // Attach punctuation mark to the previous word\n                    words[words.length - 1] += ' ' + char;\n                }\n            }\n        } else {\n            // char is a whitespace\n            if (isCurrentHighlighted) {\n                currentWord += char;\n            } else if (currentWord) {\n                words.push(currentWord);\n                currentWord = '';\n            }\n        }\n    }\n\n    if (currentWord) {\n        words.push(currentWord);\n    }\n\n    return words;\n}","import {Caption, Word} from '../common/captions';\nimport {CssProcessor} from './css-processor';\n\nexport class CaptionRenderer {\n    public constructor(private readonly cssProcessor: CssProcessor) {\n    }\n\n    public renderCaption(caption: Caption): HTMLDivElement {\n        const captionDiv = document.createElement('div');\n        captionDiv.setAttribute('id', `caption_${caption.index}`);\n        captionDiv.setAttribute('class', 'caption');\n\n        caption.words\n            .map(word => this.renderWord(word, caption))\n            .forEach(spanElem => captionDiv.appendChild(spanElem));\n\n        const captionWords = caption.words.map(word => word.rawWord);\n        return this.cssProcessor.applyDynamicClasses(captionDiv, caption.index, caption.startTimeMs, captionWords);\n    }\n\n    private renderWord(word: Word, caption: Caption): HTMLSpanElement {\n        const cssClasses = CaptionRenderer.wordSpanClasses(word);\n        const wordSpan = document.createElement('span');\n        wordSpan.textContent = word.rawWord;\n        wordSpan.classList.add(...cssClasses);\n\n        return this.cssProcessor.applyDynamicClasses(wordSpan, caption.index, caption.startTimeMs, [ word.rawWord ]);\n    }\n\n    public static wordSpanClasses(word: Word): Set<string> {\n        const cssClasses = new Set([ 'word' ]);\n\n        if (word.isHighlighted) {\n            cssClasses.add(word.highlightClass || 'highlighted');\n        } if (word.isBeforeHighlighted) {\n            cssClasses.add('before-highlighted');\n        } if (word.isAfterHighlighted) {\n            cssClasses.add('after-highlighted');\n        }\n\n        return cssClasses;\n    }\n}","import {Caption, haveSameWords} from '../common/captions';\nimport {CaptionRenderer} from './caption-renderer';\nimport {CssProcessor} from './css-processor';\n\nexport class Player {\n    public onStop = () => {};\n\n    private readonly captionsContainer: HTMLDivElement;\n    private readonly rendered: HTMLDivElement[] = [];\n    private timeoutIds: NodeJS.Timeout[] = [];\n    private displayedCaptionId = 0;\n\n    constructor(private readonly videoElem: HTMLElement,\n                private readonly captions: Caption[],\n                private readonly cssProcessor: CssProcessor,\n                renderer: CaptionRenderer) {\n        this.captionsContainer = this.videoElem.querySelector('.captions')!;\n\n        for (let i = 0; i < captions.length; i++) {\n            const caption = captions[i];\n            this.rendered[caption.index] = i > 0 && haveSameWords(caption, captions[i - 1])\n                ? this.rendered[caption.index - 1]\n                : renderer.renderCaption(caption);\n        }\n    }\n\n    public play() {\n        this.rendered.forEach(captionElem => captionElem.remove());\n\n        if (this.captions.length === 0) {\n            return;\n        }\n\n        for (let i = 0; i < this.captions.length; i++) {\n            const caption = this.captions[i];\n            const displayTimeoutId = setTimeout(() => {\n                this.displayCaption(caption.index);\n            }, caption.startTimeMs);\n            this.timeoutIds.push(displayTimeoutId);\n\n            if (i < this.captions.length - 1) {\n                const nextCaption = this.captions[i + 1];\n\n                if (!haveSameWords(caption, nextCaption)) {\n                    const hideTimeoutId = setTimeout(() => {\n                        this.hideCaption(caption.index);\n                    }, caption.endTimeMs);\n                    this.timeoutIds.push(hideTimeoutId);\n                }\n            } else {\n                const hideTimeoutId = setTimeout(() => {\n                    this.hideCaption(caption.index);\n                    this.stop();\n                }, caption.endTimeMs);\n                this.timeoutIds.push(hideTimeoutId);\n            }\n        }\n    }\n\n    public stop() {\n        if (this.displayedCaptionId) {\n            this.rendered[this.displayedCaptionId].remove();\n            this.displayedCaptionId = 0;\n        }\n\n        while (this.timeoutIds.length) {\n            clearTimeout(this.timeoutIds.pop());\n        }\n\n        this.onStop();\n    }\n\n    public prec() {\n        if (!this.isBeginning) {\n            let precId = this.displayedCaptionId - 1;\n            if (precId) {\n                this.displayCaption(precId);\n            } else {\n                this.hideCaption(this.displayedCaptionId)\n            }\n        }\n    }\n\n    public next() {\n        if (!this.isEnd) {\n            this.displayCaption(this.displayedCaptionId + 1);\n        }\n    }\n\n    public get isBeginning(): boolean {\n        return this.displayedCaptionId === 0;\n    }\n\n    public get isEnd(): boolean {\n        return this.displayedCaptionId === this.captions.length\n    }\n\n    private displayCaption(index: number) {\n        if (this.displayedCaptionId === index) {\n            return;     // Displayed already, do nothing\n        }\n\n        if (this.displayedCaptionId) {\n            const displayedCaption = this.captions[this.displayedCaptionId - 1];\n            const nextCaption = this.captions[index - 1];\n\n            if (haveSameWords(displayedCaption, nextCaption)) {\n                const renderedCaption = this.rendered[this.displayedCaptionId];\n\n                const captionWords = nextCaption.words.map(word => word.rawWord);\n                this.cssProcessor.applyDynamicClasses(renderedCaption, index, nextCaption.startTimeMs, captionWords);\n\n                const renderedWords = renderedCaption.querySelectorAll('.word');\n                for (let i = 0; i < renderedWords.length; i++) {\n                    const word = nextCaption.words[i];\n                    const renderedWord = renderedWords[i] as HTMLElement;\n\n                    const cssClasses = CaptionRenderer.wordSpanClasses(word);\n                    const existingClasses = new Set([...renderedWord.classList.values()]);\n\n                    const classesToRemove = existingClasses.difference(cssClasses);\n                    const classesToAdd = cssClasses.difference(existingClasses);\n\n                    renderedWord.classList.remove(...classesToRemove);\n                    renderedWord.classList.add(...classesToAdd);\n\n                    this.cssProcessor.applyDynamicClasses(renderedWord, index, nextCaption.startTimeMs, [ word.rawWord ]);\n                }\n            } else {\n                this.rendered[this.displayedCaptionId].remove();\n                this.captionsContainer.appendChild(this.rendered[index]);\n            }\n        } else {\n            this.captionsContainer.appendChild(this.rendered[index]);\n        }\n\n        this.dynamicallyStyleContainers(index);\n        this.displayedCaptionId = index;\n    }\n\n    private dynamicallyStyleContainers(index: number) {\n        this.videoElem.setAttribute('class', '');\n        this.captionsContainer.setAttribute('class', 'captions');\n\n        const caption = this.captions[index - 1];\n        const captionWords = caption.words.map(word => word.rawWord);\n        this.cssProcessor.applyDynamicClasses(this.videoElem, index, caption.startTimeMs, captionWords);\n        this.cssProcessor.applyDynamicClasses(this.captionsContainer, index, caption.startTimeMs, captionWords);\n    }\n\n    private hideCaption(index: number) {\n        if (this.displayedCaptionId != index) {\n            return;     // Removed already, do nothing\n        }\n\n        this.rendered[index].remove();\n        this.displayedCaptionId = 0;\n    }\n}","<script setup lang=\"ts\">\nimport {reactive} from 'vue';\n\nconst playerState = reactive({\n  isPlaying: false,\n  isBeginning: window.Player.isBeginning,\n  isEnd: window.Player.isEnd,\n});\n\nwindow.Player.onStop = () => {\n  playerState.isPlaying = false;\n};\n\nfunction prec() {\n  window.Player.prec();\n  updateState();\n}\n\nfunction next() {\n  window.Player.next();\n  updateState();\n}\n\nfunction togglePlay() {\n  if (!playerState.isPlaying) {\n    window.Player.play();\n    playerState.isPlaying = true;\n  } else {\n    window.Player.stop();\n  }\n}\n\nfunction updateState() {\n  playerState.isBeginning = window.Player.isBeginning;\n  playerState.isEnd = window.Player.isEnd;\n}\n</script>\n\n<template>\n  <section id=\"player-controller\" class=\"section is-small\">\n    <div class=\"field has-addons has-addons-centered\">\n      <p class=\"control\">\n        <button class=\"button is-rounded\"\n                :disabled=\"playerState.isBeginning || playerState.isPlaying\"\n                @click=\"prec()\">\n          <span class=\"icon is-small\">\n            <i class=\"fa fa-backward\"></i>\n          </span>\n          <span>Prec</span>\n        </button>\n      </p>\n      <p class=\"control\">\n        <button class=\"button\"\n                :class=\"[ playerState.isPlaying ? 'is-danger' : 'is-primary' ]\"\n                @click=\"togglePlay()\">\n          <span class=\"icon is-small\">\n            <i class=\"fa\"\n               :class=\"[ playerState.isPlaying ? 'fa-stop' : 'fa-play' ]\">\n            </i>\n          </span>\n          <span>Play</span>\n        </button>\n      </p>\n      <p class=\"control\">\n        <button class=\"button is-rounded\"\n                :disabled=\"playerState.isEnd || playerState.isPlaying\"\n                @click=\"next()\">\n          <span class=\"icon is-small\">\n            <i class=\"fa fa-forward\"></i>\n          </span>\n          <span>Next</span>\n        </button>\n      </p>\n    </div>\n  </section>\n</template>","import {toMillis} from '../common/timecodes';\n\nexport type FilterType = 'indexes' | 'timecodes' | 'words';\n\nexport interface Filter {\n    cssClass: string;\n    type: FilterType;\n    args: string[];\n}\n\nexport function normalizeTimecode(timecode: string): string {\n    const [ hh, mm, ss, ms ] = timecode.split(/[^\\d]+/);\n    return `${hh}:${mm}:${ss}.${ms}`;\n}\n\nexport abstract class AbstractDynamicCssRule {\n    protected constructor(protected readonly targetSelectors: string[],\n                          public readonly appliedCssClass: string) {\n    }\n\n    public isApplied(target: HTMLElement, captionIndex: number, timeMs: number, words: string[]): boolean {\n        let targetClasses = target.getAttribute('class')?.split(' ') || [];\n\n        for (const targetSelector of this.targetSelectors) {\n            if (targetSelector.startsWith('#')) {\n                const idSelector = targetSelector.slice(1);\n                if (target.getAttribute('id') != idSelector) {\n                    return false;\n                }\n            } else if (targetSelector.startsWith('.')) {\n                const classSelector = targetSelector.slice(1);\n                if (!targetClasses.includes(classSelector)) {\n                    return false;\n                }\n            } else {\n                throw new Error(`Unsupported target selector: '${targetSelector}'`);\n            }\n        }\n\n        return true;\n    }\n}\n\nexport class IndexesDynamicCssRule extends AbstractDynamicCssRule {\n    constructor(targetSelectors: string[],\n                appliedCssClass: string,\n                private readonly startIndexInclusive: number,\n                private readonly endIndexInclusive?: number) {\n        super(targetSelectors, appliedCssClass);\n    }\n\n    isApplied(target: HTMLElement, captionIndex: number, timeMs: number, words: string[]): boolean {\n        return super.isApplied(target, captionIndex, timeMs, words)\n            && this.startIndexInclusive <= captionIndex\n            && (this.endIndexInclusive ? this.endIndexInclusive >= captionIndex : true);\n    }\n}\n\nexport class TimecodesDynamicCssRule extends AbstractDynamicCssRule {\n    constructor(targetSelectors: string[],\n                appliedCssClass: string,\n                private readonly startTimeMsInclusive: number,\n                private readonly endTimeMsInclusive?: number) {\n        super(targetSelectors, appliedCssClass);\n    }\n\n    isApplied(target: HTMLElement, captionIndex: number, timeMs: number, words: string[]): boolean {\n        return super.isApplied(target, captionIndex, timeMs, words)\n            && this.startTimeMsInclusive <= timeMs\n            && (this.endTimeMsInclusive ? this.endTimeMsInclusive >= timeMs : true);\n    }\n}\n\nexport function createDynamicCssRule(targetSelectors: string[], filter: Filter): AbstractDynamicCssRule {\n    switch (filter.type) {\n        case 'indexes':\n            const [ startIndex, endIndex ] = filter.args.map(arg => Number(arg));\n            return new IndexesDynamicCssRule(targetSelectors, filter.cssClass, startIndex, endIndex);\n        case 'timecodes':\n            const [ startMs, endMs ] = filter.args.map(normalizeTimecode).map(toMillis);\n            return new TimecodesDynamicCssRule(targetSelectors, filter.cssClass, startMs, endMs);\n        default:\n            throw new Error(`Unknown filter type '${filter.type}'!`);\n    }\n}","import {AbstractDynamicCssRule, createDynamicCssRule, Filter, FilterType} from '../common/dynamic-css-rules';\n\nconst dynamicCssClassPrefix = 'pup-';\nconst dynamicCssClassPattern = /^\\.pup-(\\w+)((?:-[^-]+)+)$/;\n\nexport class CssProcessor {\n    private readonly dynamicCssRules: AbstractDynamicCssRule[] = [];\n\n    constructor() {\n        for (const styleSheet of document.styleSheets) {\n            for (const styleRule of styleSheet.cssRules) {\n                const selectorText = (styleRule as CSSStyleRule).selectorText || '';\n\n                if (selectorText.includes('.pup-')) {\n                    const selectors = CssProcessor.parseSelectors(selectorText);\n                    const targetSelectors: string[] = [];\n                    let filter: Filter | null = null;\n\n                    for (const selector of selectors) {\n                        if (selector.match(dynamicCssClassPattern)) {\n                            if (filter) {\n                                throw new Error(\n                                    `Only one dynamic CSS class is allowed per style rule. \n                                    Two dynamic classes were found: .${filter.cssClass} and ${selector}`);\n                            }\n\n                            filter = CssProcessor.parseFilter(selector);\n                        } else {\n                            targetSelectors.push(selector);\n                        }\n                    }\n\n                    const rule = createDynamicCssRule(targetSelectors, filter!);\n                    this.dynamicCssRules.push(rule);\n                }\n            }\n        }\n    }\n\n    public applyDynamicClasses<T extends HTMLElement>(target: T, captionIndex: number, timeMs: number, words: string[]): T {\n        const dynamicCssClasses = this.dynamicCssClasses(target, captionIndex, timeMs, words);\n        const existingDynamicClasses = CssProcessor.getDynamicCssClassesFromElem(target);\n\n        const classesToRemove = existingDynamicClasses.difference(dynamicCssClasses);\n        const classesToAdd = dynamicCssClasses.difference(classesToRemove);\n\n        target.classList.remove(...classesToRemove);\n        target.classList.add(...classesToAdd);\n\n        return target;\n    }\n\n    private dynamicCssClasses(target: HTMLElement, captionIndex: number, timeMs: number, words: string[]): Set<string> {\n        const cssClasses = this.dynamicCssRules\n            .filter(rule => rule.isApplied(target, captionIndex, timeMs, words))\n            .map(rule => rule.appliedCssClass);\n        return new Set(cssClasses);\n    }\n\n    public static getDynamicCssClassesFromElem(elem: HTMLElement): Set<string> {\n        const dynamicCssClasses = [...elem.classList.values()]\n            .filter(cssClass => cssClass.startsWith(dynamicCssClassPrefix));\n        return new Set(dynamicCssClasses);\n    }\n\n    static parseFilter(dynamicCssClass: string): Filter {\n        const match = dynamicCssClass.match(dynamicCssClassPattern);\n\n        if (!match) {\n            throw new Error(`CSS class ${dynamicCssClass} do not match required pattern!`);\n        }\n\n        const cssClass = dynamicCssClass.slice(1);\n        const filterType = match[1] as FilterType;\n        const filterArgs = match[2].split('-').slice(1);\n\n        return {\n            cssClass,\n            type: filterType,\n            args: filterArgs,\n        }\n    }\n\n    static parseSelectors(selectorText: string): string[] {\n        const selectors: string[] = [];\n        let currentToken = '';\n        let lastIsEscaped = false;\n\n        for (let i = 0; i < selectorText.length; i++) {\n            const char = selectorText[i];\n            if ((char === '.' || char === '#') && !lastIsEscaped) {\n                if (currentToken) {\n                    selectors.push(currentToken);\n                }\n                currentToken = char;\n            } else if (char === '\\\\') {\n                currentToken += char;\n                lastIsEscaped = true;\n            } else if (lastIsEscaped) {\n                currentToken += char;\n                lastIsEscaped = false;\n            } else {\n                currentToken += char;\n            }\n        }\n\n        if (currentToken) {\n            selectors.push(currentToken);\n        }\n\n        return selectors;\n    }\n}\n","import {createApp} from 'vue';\nimport {Player} from './player';\nimport PlayerComponent from './components/player.component.vue';\nimport {CssProcessor} from './css-processor';\nimport {CaptionRenderer} from './caption-renderer';\n\nwindow.ready = new Promise((resolve, reject) => {\n    window.onload = () => {\n        const videoElem = document.getElementById('video');\n        const cssProcessor = new CssProcessor();\n        const renderer = new CaptionRenderer(cssProcessor);\n        window.Player = new Player(videoElem!, window.captions, cssProcessor, renderer);\n\n        if (window.playerArgs.isPreview) {\n            createApp({})\n                .component('player', PlayerComponent)\n                .mount('#player-controller');\n        }\n\n        resolve();\n    };\n});\n"],"names":["reactive","createApp","PlayerComponent"],"mappings":"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"}